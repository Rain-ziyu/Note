# 数据库常用的数据结构与算法

作为一个知名的关系型数据库，Mysql在底层许多地方都有着对数据结构与算法的极致运用。接下来将主要以Mysql为例从几个不同的功能点进行解析数据库中那些应用的很妙的算法与数据结构设计。

## 排序算法

> 对于所有数据库程序而言，良好的排序性能都是一个不可避免的难题。

当然排序算法有非常多种，每一种排序算法都有其优势与劣势。
Mysql在大规模数据时采用了归并排序，通过归并排序将问题拆分为小问题。

**为什么是归并排序？**
* 节省内存空间。归并排序是不创建新的序列而是直接修改输入序列。注：这种算法叫『原地算法』(in-place algorithm)
* 可以同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。注：这种算法叫『外部排序』(external sorting)。
* 可以充分利用 多处理器/多线程/多服务器 上的优势。比如，分布式合并排序是Hadoop（那个著名的大数据框架）的关键组件之一。

## 查找算法（数据库索引）

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。


### 二叉搜索树

> 数据库中查询的时间复杂度限制，使我们无法直接使用矩阵进行查询，因此需要使用二叉搜索树(BST)。

使用二叉搜索树只需 log(N) 次运算，而如果你直接使用数据矩阵则需要 N 次运算。

> 在查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。

### B+树索引的引入

> 由于上述二叉搜索树的问题，就引入了基于二叉搜索树优化后的B+树来解决以上问题。

#### B+ Tree 原理

##### 数据结构

B Tree 指的是 Balance Tree，也就是平衡树（平衡多路查找树）。平衡树是一颗查找树，通过左右旋转让所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key[i] 和 key[i+1]，且不为 null，则该指针指向节点的所有 key 大于等于 key[i] 且小于 key[i+1]。

![](./images/Mysql/B+树.png)

##### 查询过程

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。因此过多的索引会导致插入删除性能降低。

##### 与红黑树比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:

(一)更少的查找次数

平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。

(二)利用计算机预读特性，优化范围查找

为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。

#### B+树索引

B+树索引是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。

除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。

主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把实际数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
![](./images/Mysql/聚簇索引.jpg)

辅助索引(聚簇索引c)的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

![](./images/Mysql/非聚簇索引.jpg)

### 哈希索引

在Mysql中除了主流的B+树索引，还有哈希索引。

哈希索引能以 O(1) 时间进行指定元素查找，但是失去了有序性，因此它具有以下限制:
* 无法用于排序与分组；
* 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 全文索引

其实MySQL中也有类似ES的全文索引用于简单的分词查询。全文索引（Full-Text Index）是一种用于加速文本数据搜索的索引类型。它允许你在文本列（如 VARCHAR、TEXT 等）上执行高效的全文搜索，而不仅仅是简单的模式匹配。

mysql的全文索引也使用倒排索引实现，它记录着关键词到其所在文档的映射。

最早全文索引仅支持MyISAM 存储引擎，但是5.6.4 版后也增加了InnoDB 存储引擎的支持，但是5.7版本之后Mysql内置了ngram全文检索插件，用于支持中文分词。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE like。具体语法可以参考[MySQL官网](https://dev.mysql.com/doc/refman/8.4/en/fulltext-natural-language.html)

**以上内容就是目前Mysql中比较重要的索引实现。**

