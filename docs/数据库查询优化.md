# 在判断一个SQL该如何优化之前我们需要先进性分析

## 使用 Explain 进行分析
Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。
比较重要的字段有:
* select_type : 查询类型，有简单查询、联合查询、子查询等
* key : 使用的索引
* rows : 扫描的行数
* extral: 使用索引的情况

以下对extral字段中出现的一些参数进行说明：
#### Using index
使用了索引进行查询。

例如：

假设test表只有主键id有索引，name没有索引，那么查询时就是把所有满足id > 100的数据行返回给Server层，然后Server层根据name='123'进行过滤，所有使用explain时会发现extra那里显示的是Using where
```sql
SELECT * FROM test where id > 100 AND name = '123'
```
#### Using where
一般就是where条件中一些判断字段没有索引，那么这个条件的过滤就会在Server端进行 在innodb数据引擎将结果返回给Server层后，MySQL Server层对数据进行进一步的过滤，然后返回结果。

#### Using index condition
这个就是在MySQL5.6以后，做的一个优化，例如有一个联合索引(a，b，c)

查询条件为where a = '123' AND b like '%aa% AND c like '%cc%'时，按照联合索引的最左匹配法则，只有a可以用上索引，以前版本的MySQL中，innodb存储引擎就会在联合索引把满足a = '123'的数据的主键id找出来，然后回表，然后把所有数据发送给Sever端，Server端根据b like '%aa% AND c like '%cc%'对数据进行过滤，

现在有这个push down优化，因为联合索引中有b和c两个字段的信息，innodb在联合索引查找时就会考虑到b like '%aa% AND c like '%cc%'条件，所有回表的数据就都会是满足这三个条件的，然后返回给Server端的也都是满足条件的数据行，Server端就不会再自己进行数据过滤了。
#### Using filesort
如果在关联表查询时，Order By的所有字段都来自第一个表(也就是驱动表)，那么在处理驱动表时，从驱动表中取出满足条件的结果集时就会进行排序，不需要使用临时表存储数据行进行重排序，extral那一列就会显示是Using index。如果Order By的字段不在索引中，那么就需要在查找出结果集后，进行重排序，就会显示Using filesort。
#### Using temporary; Using fileSort
在进行关联表查询时，如果Order By中的字段不全是来自驱动表，也就是使用了被驱动表中的字段进行排序，那么会把关联结果全部查找出来，存放在临时表中，等所有的关联都结束后，再在内存中对数据行进行排序。

#### 具体优化方向
1. 优化索引使用情况。使用explain SQL查看解析结果，首先看结果中Extra那一列是否有Using Index，如果没有看是否是where判断条件的字段没有添加索引，不能使用索引。如果出现的是Using Where，可能是where子句里面判断的字段没有加索引，这样innodb就会把所有数据行查询出来，返回给MySQL Server层，Server层做的过滤。

2. 减少扫描的行数。查看explain SQL解析结果中rows那一列，看行数是不是特别多，通过添加索引的方式减少扫描的行数。

3. 只查询我们需要的列。看SQL中的查询字段是不是都是我们需要的，只选取我们需要的字段，而不是所有查询SQL都是使用SELECT *，这些多的字段的存在，会增大查询的时间，以及网络传输的数据量。

4. 优化join的方式，一般join的字段在被驱动表中有索引，那么join使用的算法就会是index Nested-Loop Join，如果没有索引那么就是block Nested-Loop Join。尽量让join的字段有索引可以使用，实在不行，可以增加join buffer Size的大小(默认是256K)。

5. 如果单表数据量大于1000万，考虑进行分库分表。
## 使用show profile对一条SQL查询分析当前会话中语句执行的资源消耗情况

1. profiling配置默认是不开启的，可以使用set profiling = ON;命令将配置暂时打开。

2. 执行一条查询SQL

3. 使用show profiles可以查看最近15条查询SQL及对应的查询idquery id

4. 假设查询id为9，使用这个命令show profile for query 9;可以查看每个步骤及其消耗的时间，关注耗时的地方进行优化。

示例如下：
```sql
set profiling = ON;
-- 执行有问题的SQL
select m.*
from menu m
         left join role_menu rm on m.id = rm.menu_id
         left join account_role ar on rm.role_id = ar.role_id
         left join role r on rm.role_id = r.id
where m.has_deleted = 0
  and r.status = 1
group by m.id, m.sort
order by m.sort;
-- 查询所有query id
show profiles;
-- 查询对应sql的步骤分析
show profile for query 52;

set profiling = OFF;
```
常见返回结果备注：
```shell
type:  
 | ALL              --显示所有的开销信息  
 | BLOCK IO         --显示块IO相关开销  
 | CONTEXT SWITCHES --上下文切换相关开销  
 | CPU              --显示CPU相关开销信息  
 | IPC              --显示发送和接收相关开销信息  
 | MEMORY           --显示内存相关开销信息  
 | PAGE FAULTS      --显示页面错误相关开销信息  
 | SOURCE           --显示和Source_function，Source_file，Source_line相关的开销信息  
 | SWAPS            --显示交换次数相关开销的信息
```
核心关注点：

① converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。常发生在MyISAM
② Creating tmp table 创建临时表

　　　　拷贝数据到临时表

　　　　用完再删除

③ Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！这种通常是比较耗时的
④ locked
参考以上结果帮助我们进行详细的SQL优化。

## 主要可优化方向

1. 减少请求的数据量
* 只返回必要的列: 最好不要使用 SELECT * 语句。
* 只返回必要的行: 使用 LIMIT 语句来限制返回的数据。
* 缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

2. 减少服务器端扫描的行数

最有效的方式是使用索引来覆盖查询。

3. 针对SQL语句重构查询方式

将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:
* 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，其它表的查询缓存依然可以使用。
* 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
* 减少锁竞争；
* 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。查询本身效率也可能会有所提升。
* 例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。
```sql
-- 直接进行连接
SELECT * FROM tab
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
-- 在应用内联查
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

