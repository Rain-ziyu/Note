# 数据库的主要组成部分（并不是特指Mysql）

数据库一般可以用如下图形来理解：
![](./images/Mysql/Mysql组成部分.png)
### 核心组件：

* 进程管理器（process manager）：数据库需要具备一个妥善管理的进程/线程池。为了实现纳秒级操作，一些现代数据库都使用自己的线程而不是操作系统线程。
* 网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以数据库需要具备自己的网络管理器。
* 文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。需要一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。
* 内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。特别是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。
* 安全管理器（Security Manager）：用于对用户的验证和授权。
* 客户端管理器（Client manager）：用于管理客户端连接。
* ……

### 工具
在数据库中一般中内置了一些常用的数据库工具，比如：

* 备份管理器（Backup manager）：用于保存和恢复数据。
* 恢复管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。
* 监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。
* 管理员管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。
* ……
### 查询管理器
几乎我们所有的SQL都会经过这一部分进行优化处理
* 查询解析器（Query parser）：用于检查查询是否合法
* 查询重写器（Query rewriter）：用于预优化查询
* 查询优化器（Query optimizer）：用于优化查询
* 查询执行器（Query executor）：用于编译和执行查询

### 数据管理器

* 事务管理器（Transaction manager）：用于处理事务
* 缓存管理器（Cache manager）：数据被使用之前置于内存，或者数据被写入磁盘之前置于内存
* 数据访问管理器（Data access manager）：访问磁盘中的数据


## SQL查询的流程

首先一条SQL的传输会经过客户端管理器层。

### 客户端管理器

> 客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。

![](./images/Mysql/客户端管理器.png)

**当你连接到数据库时：**
* 管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。
* 然后，管理器检查是否有空闲进程（或线程）来处理你对查询。
* 管理器还会检查数据库是否负载很重。
* 管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。
* 如果得到了资源，然后管理器会把你的查询送给查询管理器来处理。
* 因为查询处理进程是流式处理的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。
* 如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。

接下来合法并被分配到资源的查询就会来到查询管理器。

### 查询管理器

> 这部分是数据库的威力所在，在这部分里，一个写得糟糕的查询可以转换成一个快速执行的代码，代码执行的结果将被送到客户端管理器。

这个多步骤操作过程如下：
* 查询首先被解析并判断是否合法
* 然后被重写，去除了无用的操作并且加入预优化部分
* 接着被优化以便提升性能，并被转换为可执行代码和数据访问计划
* 然后计划被编译最后，被执行

作为SQL执行的核心部分，查询会在该层主要经过一下几个部分：

#### 查询解析器

> 每一条SQL语句都要送到解析器来检查语法，如果你的查询有错，解析器将拒绝该查询。比如，如果你写成”SLECT …” 而不是 “SELECT …”，那就没有下文了。

但这还不算完，解析器还会检查关键字是否使用正确的顺序，比如 WHERE 写在 SELECT 之前会被拒绝。

然后，解析器要分析查询中的表和字段，使用数据库元数据来检查：

* 表是否存在
* 表的字段是否存在
* 对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）

接着，解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。

在解析过程中，SQL 查询被转换为内部表示（通常是一个树）。

如果一切正常，内部表示被送到查询重写器。

#### 查询重写器

在这一步，我们已经有了查询的内部表示，重写器的目标是：

* 预优化查询
* 避免不必要的运算
* 帮助优化器找到合理的最佳解决方案

重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。下面是（可选）规则的非详尽的列表：

* 视图合并：如果你在查询中使用视图，视图就会转换为它的 SQL 代码。
* 子查询扁平化：子查询是很难优化的，因此重写器会尝试移除子查询 
* 去除不必要的运算符：比如，如果你用了 DISTINCT，而其实你有 UNIQUE 约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。
* 排除冗余的联接：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用 JOIN，都会被消除。
* 常数计算赋值：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE > 10+2 会转换为 WHERE AGE > 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。

#### 查询优化器

> 所有的现代数据库都在用基于成本的优化（即CBO）来优化查询。原理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。

因此评估成本就会涉及到时间复杂度、CPU消耗磁盘IO等的评估。当然评估优化过程是复杂的，而且评估不能保证得到的一定是最好的，因为因素是多方面的。具体的评估优化过程就不在详细解释。

#### 查询执行器
在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器。

### 数据管理器

在查询管理器中经过多次处理转换最终SQL到达数据管理器层，需要去进行实际数据的提取。
![](./images/Mysql/数据管理器.png)
在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。但是有 2 个问题：
* 关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。
* 数据提取是数据库中速度最慢的操作，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。

在该层又会经过缓存管理器（降低IO瓶颈）、事务管理器（保证每个查询在自己的事务内执行的）、锁管理器（确保隔离性、一致性和原子性）、日志管理器（数据库把数据保存在内存缓冲区内，但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的持久性，使用日志来进行保证）